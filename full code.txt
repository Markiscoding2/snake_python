```gdata.py
import pygame
import random
from pygame import *


class GData:
    def __init__(self):

        pygame.init()
        pygame.display.set_caption("Snake")

        self.screen = pygame.display.set_mode((1920, 1080), FULLSCREEN)
        self.screen.fill((0, 0, 0))

        self.S_WIDTH = self.screen.get_width()
        self.S_HEIGHT = self.screen.get_height()
        
        self.BUTTONS_WIDTH = 196

        self.options_showed = False
        self.difficulty = 20
        self.solid_wall = False
        self.golden_apple = False
        self.music_playing = False

        
        self.clock = pygame.time.Clock()
        self.clock.tick(self.difficulty)
        self.running = True

        self.font = pygame.font.Font(None, 50)

        self.alg = 0
        self.menu_showed = False
```

```menu.py
import pygame
from pygame import *
import random
from game_data import GData
from player import Player


class Menu:
    def __init__(self, options, selected_options):
        self.options = options
        self.selected_options = selected_options

        self.NUMBER_OF_OPTIONS = len(self.options)
        self.NUMBER_OF_SELECTED_OPTIONS = len(self.selected_options)

        self.selected_index = 0
        self.menu_showed = False
        
        self.last_key_press = 0 
        self.key_delay = 200  
    def handle_input(self):
        current_time = pygame.time.get_ticks()
        currrent_menu_key = pygame.key.get_pressed()

        if current_time - self.last_key_press > self.key_delay:

            if currrent_menu_key[pygame.K_w] and self.selected_index > 0:
                self.selected_index -= 1
                self.last_key_press = current_time  # Update key press time

            if currrent_menu_key[pygame.K_s] and self.selected_index < len(self.options) - 1:
                self.selected_index += 1
                self.last_key_press = current_time  # Update key press time
            
            if currrent_menu_key[pygame.K_RETURN]:
                self.last_key_press = current_time  # Update key press time

        return currrent_menu_key
    def render_menu(self, gdata):
        for i in range(self.NUMBER_OF_OPTIONS):
            selected_image = self.selected_options[i]
            images = self.options[i]
            if i == self.selected_index:
                gdata.screen.blit(
                    selected_image,
                    (
                        gdata.S_WIDTH / 2 - gdata.BUTTONS_WIDTH / 2,
                        gdata.S_HEIGHT / 2 + 70 * i,
                    ),
                )
            else:
                gdata.screen.blit(
                    images,
                    (
                        gdata.S_WIDTH / 2 - gdata.BUTTONS_WIDTH / 2,
                        gdata.S_HEIGHT / 2 + 70 * i,
                    ),
                )
        
    def options_menu(self,gdata,main_menu):
        #idea: create 3 seperate difficulty images: easy,medium,hard, implement logic by adding some booleans checking which difficulty is chosen based on the current framerate
        #for the golden apple just check the current state and if true show under it
        #for the wall do the same
        current_menu_key = self.handle_input()
        self.render_menu(gdata)
        gdata.clock.tick(20)
        if current_menu_key[pygame.K_RETURN]:
            if self.selected_index == 0:
                gdata.difficulty += 5
                if gdata.difficulty > 30:
                    gdata.difficulty = 20
            elif self.selected_index == 1:
                gdata.solid_wall = not gdata.solid_wall
            elif self.selected_index == 2:
                gdata.golden_apple = not gdata.golden_apple
            elif self.selected_index == 3:
                gdata.options_showed = False
                main_menu.menu_showed = False
                self.selected_index = 2
            pygame.time.wait(200)




    def goprint_menu(self, player, gdata, main_menu):
        current_menu_key = self.handle_input()
        self.render_menu(gdata)
        if current_menu_key[pygame.K_RETURN]:
            player.dead = False  # Revive player
            pygame.time.wait(200)

        if not player.dead:
            if self.selected_index == 0:
                player.__init__()  # Reset Player
                main_menu.menu_showed = False  # Return to main menu
                gdata.music_playing = False
            elif self.selected_index == 1:
                gdata.running = False



    def print_menu(self, gdata):
        CURRENT_MENU_KEY = self.handle_input()
        self.render_menu(gdata)
        if CURRENT_MENU_KEY[pygame.K_RETURN]:
            self.menu_showed = True
            pygame.time.wait(200)


        if self.selected_index == 1 and self.menu_showed == True:
            gdata.options_showed = True
            self.menu_showed = False
        if self.selected_index == 2 and self.menu_showed == True:
            gdata.running = False
```

```player.py
import pygame
import random
from collections import deque
from pygame import *


class Player:
    def __init__(self):
        self.GRID_SIZE = 40

        self.START_WIDTH = 800
        self.START_HEIGHT = 640

        self.X_BOUNDS = 1880
        self.Y_BOUNDS = 1040

        self.apple_sprite = pygame.image.load("src/sprites/apple.png")

        self.position = Vector2(self.START_WIDTH, self.START_HEIGHT)
        self.direction = Vector2(0, 0)

        self.segments = deque()
        self.score = 0

        self.dead = False
        self.apple_position = Vector2(
            random.randrange(self.GRID_SIZE, self.X_BOUNDS, self.GRID_SIZE),
            random.randrange(self.GRID_SIZE, self.Y_BOUNDS, self.GRID_SIZE),
        )

    def add_segment(self):
        self.segments.append([self.position.x, self.position.y])

    def Movement(self, gdata,main_menu):

        current_pressed_key = pygame.key.get_pressed()
        if current_pressed_key[pygame.K_ESCAPE]:
            gdata.running = False


        if current_pressed_key[pygame.K_a] and self.direction.x == 0 and not current_pressed_key[pygame.K_w] and not current_pressed_key[pygame.K_s] :
            self.direction = Vector2(-1, 0)

        if current_pressed_key[pygame.K_d] and self.direction.x == 0 and not current_pressed_key[pygame.K_w] and not current_pressed_key[pygame.K_s]:
            self.direction = Vector2(1, 0)

        if current_pressed_key[pygame.K_w] and self.direction.y == 0:

            self.direction = Vector2(0, -1)

        if current_pressed_key[pygame.K_s] and self.direction.y == 0:
            self.direction = Vector2(0, 1)

        if self.direction == Vector2(0, 0):
            return

        new_position = self.position + self.direction * self.GRID_SIZE

        if not gdata.solid_wall:
            if new_position.x < 0:
                new_position.x = self.X_BOUNDS
            elif new_position.x > self.X_BOUNDS:
                new_position.x = 0
                
            if new_position.y < 0:
                new_position.y = self.Y_BOUNDS
            elif new_position.y > self.Y_BOUNDS:
                new_position.y = 0
        
            if 0 <= new_position.x <= self.X_BOUNDS and 0 <= new_position.y <= self.Y_BOUNDS:
                old_position = self.position
                self.position = new_position

                if self.segments:
                    self.segments.appendleft(old_position)
                    self.segments.pop()
        else:
            if new_position.x <= 0 or new_position.x >= self.X_BOUNDS or new_position.y <= 0 or new_position.y >= self.Y_BOUNDS:
                self.dead = True
                main_menu.menu_showed = False
                self.position = (800, 640)
                self.segments.clear()
                self.score = 0
                return

            if 0 < new_position.x < self.X_BOUNDS and 0 < new_position.y < self.Y_BOUNDS:
                old_position = self.position
                self.position = new_position

                if self.segments:
                    self.segments.appendleft(old_position)
                    self.segments.pop()


    def Eating(self):

        if self.position == self.apple_position:
            EATING_SFX = pygame.mixer.Sound("src\SFX\eating_SFX.mp3")
            EATING_SFX.play()
            axy = Vector2(
                random.randrange(self.GRID_SIZE, self.X_BOUNDS, self.GRID_SIZE),
                random.randrange(self.GRID_SIZE, self.Y_BOUNDS, self.GRID_SIZE)
            )
            for i in range(len(self.segments)):
                if axy == self.segments :
                    axy = Vector2(
                        random.randrange(self.GRID_SIZE, self.X_BOUNDS, self.GRID_SIZE),
                        random.randrange(self.GRID_SIZE, self.Y_BOUNDS, self.GRID_SIZE)
                    )
                    i = 0 
            

            self.apple_position = Vector2(
                random.randrange(self.GRID_SIZE, self.X_BOUNDS, self.GRID_SIZE),
                random.randrange(self.GRID_SIZE, self.Y_BOUNDS, self.GRID_SIZE),
            )
            self.score += 1
            self.add_segment()

    def rendering(self, gdata, main_menu):
        PLAYER_X, PLAYER_Y = self.position

        # APPLE_X, APPLE_Y = self.apple_position

        GRID_SIZE = self.GRID_SIZE

        PLAYER_COLOR = "green"

        gdata.screen.blit(
            self.apple_sprite,
            (
                self.apple_position.x,
                self.apple_position.y,
            ),
        )
        pygame.draw.rect(
            gdata.screen,
            PLAYER_COLOR,
            pygame.Rect(PLAYER_X, PLAYER_Y, GRID_SIZE, GRID_SIZE),
        )
        for (
            segment
        ) in self.segments:  # pentru fiecare segment in segmentele jucatorului
            if (
                segment == self.position
            ):  # daca segmentul este in pozitia jucatorului atunci jucatorul moare
                self.position = (800, 640)
                self.segments.clear()
                self.score = 0
                self.dead = True
                main_menu.menu_showed = False
                return
            pygame.draw.rect(
                gdata.screen,
                PLAYER_COLOR,
                pygame.Rect(segment.x, segment.y, GRID_SIZE, GRID_SIZE),
            )
        gdata.screen.blit(
            gdata.font.render(f"Score: {self.score}", True, (255, 0, 0)),
            (GRID_SIZE, GRID_SIZE),
        )
```

```snake.py (aka main)
import pygame
from pygame import *
from player import Player
from game_data import GData
from menu import *
from load_sprites import *

# add background
# fix menu
# fix some logic
# refactor code
# add better sprites
# implement some easter eggs for dia
# add different soundtracks, and check when a soundtrack ends

gdata = GData()
player = Player()

game_over_menu_images = [
    pygame.image.load("src/game_over/restart.png"),
    pygame.image.load("src/game_over/quit.png"),
]

game_over_menu_selected_images = [
    pygame.image.load("src/game_over/restart_selected.png"),
    pygame.image.load("src/game_over/quit_selected.png"),
]

main_menu_images = [
    pygame.image.load("src/menu/start.png"),
    pygame.image.load("src/menu/options.png"),
    pygame.image.load("src/menu/quit.png"),
]
main_menu_selected_images = [
    pygame.image.load("src/menu/start_selected.png"),
    pygame.image.load("src/menu/options_selected.png"),
    pygame.image.load("src/menu/quit_selected.png"),
]

options_menu_images = [
    pygame.image.load("src/menu/difficulty.png"),
    pygame.image.load("src/menu/solid_walls.png"),
    pygame.image.load("src/menu/golden_apple.png"),
    pygame.image.load("src/menu/quit.png")
]
options_menu_selected_images = [
    pygame.image.load("src/menu/difficulty_selected.png"),
    pygame.image.load("src/menu/solid_walls_selected.png"),
    pygame.image.load("src/menu/golden_apple_selected.png"),
    pygame.image.load("src/menu/quit_selected.png")
]

main_menu = Menu(main_menu_images, main_menu_selected_images)
go_menu = Menu(game_over_menu_images, game_over_menu_selected_images)
options_menu_images = Menu(options_menu_images,options_menu_selected_images)
background_music = pygame.mixer.Sound("src\OST\ost.mp3")

while gdata.running:
    pygame.display.flip()
    gdata.clock.tick(20)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            gdata.running = False
    
    gdata.screen.fill("black")    
    if not main_menu.menu_showed:
        if not player.dead and not gdata.options_showed:
            main_menu.print_menu(gdata)
        elif player.dead:
            background_music.stop()
            go_menu.goprint_menu(player, gdata, main_menu)
        elif gdata.options_showed:
            options_menu_images.options_menu(gdata, main_menu)
    else:
        gdata.clock.tick(gdata.difficulty)
        if not gdata.music_playing:
            background_music.play()
            background_music.set_volume(0.1)
            gdata.music_playing = True
        player.Eating()
        player.Movement(gdata,main_menu)
        player.rendering(gdata, main_menu)
    
    pygame.display.flip()
pygame.quit()
```


